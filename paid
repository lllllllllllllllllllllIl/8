local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- =========================
-- WINDOW
-- =========================
local Window = Rayfield:CreateWindow({
    Name = "Vision Hub",
    LoadingTitle = "Vision Script",
    LoadingSubtitle = "by Vision",
    ConfigurationSaving = { Enabled = false },
    Discord = {
        Enabled = true,
        Invite = "GYH92be25Z",
        RememberJoins = true
    },
    KeySystem = false
})

-- =========================
-- THROWING TAB
-- =========================
local ThrowingTab = Window:CreateTab("Throwing", nil)
ThrowingTab:CreateSection("QB Aimbot")

-- =========================
-- SLIDER VALUES
-- =========================
local DimeLead = 19
local MagLead = 6
local BulletLead = 1

local DimeHeight = 12
local MagHeight = 8
local BulletHeight = 4

local ThrowAngle = 50

-- =========================
-- QB TOGGLE
-- =========================
ThrowingTab:CreateToggle({
    Name = "QB Aimbot",
    CurrentValue = false,
    Callback = function(Value)
        if not Value then return end

        -- ==============================
        -- QB AIM SYSTEM
        -- ==============================

        local pizztype = "Dime"
        local GRAVITY = Vector3.new(0, -28, 0)

        local Players = game:GetService("Players")
        local UIS = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")
        local RS = game:GetService("ReplicatedStorage")
        local Camera = workspace.CurrentCamera
        local LocalPlayer = Players.LocalPlayer

        -- FIND THROW REMOTE
        local ThrowRemote
        for _, v in ipairs(RS.MiniGames:GetDescendants()) do
            if v:IsA("RemoteEvent") then
                ThrowRemote = v
                break
            end
        end

        local locked = false
        local lockedTarget = nil

        -- GUI
        local gui = Instance.new("ScreenGui")
        gui.Name = "QB_GUI"
        gui.ResetOnSpawn = false
        gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

        local frame = Instance.new("Frame")
        frame.Parent = gui
        frame.Size = UDim2.new(0, 320, 0, 160)
        frame.Position = UDim2.new(0.02, 0, 0.4, 0)
        frame.BackgroundColor3 = Color3.fromRGB(18,18,18)
        Instance.new("UICorner", frame).CornerRadius = UDim.new(0,12)

        local function label(txt, y)
            local l = Instance.new("TextLabel")
            l.Parent = frame
            l.Size = UDim2.new(1, -20, 0, 20)
            l.Position = UDim2.new(0, 10, 0, y)
            l.BackgroundTransparency = 1
            l.TextColor3 = Color3.fromRGB(200,255,200)
            l.Font = Enum.Font.GothamBold
            l.TextSize = 14
            l.TextXAlignment = Enum.TextXAlignment.Left
            l.Text = txt
            return l
        end

        local passLabel = label("Pass: Dime", 10)
        local targetLabel = label("Target: None", 35)

        local function style(btn)
            btn.BackgroundColor3 = Color3.fromRGB(0,0,0)
            btn.BorderColor3 = Color3.fromRGB(0,120,255)
            btn.BorderSizePixel = 2
            btn.TextColor3 = Color3.new(1,1,1)
            btn.Font = Enum.Font.GothamBold
            Instance.new("UICorner", btn).CornerRadius = UDim.new(0,10)
        end

        -- LOCK BUTTON
        local lockBtn = Instance.new("TextButton")
        lockBtn.Parent = frame
        lockBtn.Size = UDim2.new(0,120,0,32)
        lockBtn.Position = UDim2.new(0,10,0,90)
        lockBtn.Text = "LOCK"
        style(lockBtn)

        -- PASS BUTTON
        local passBtn = Instance.new("TextButton")
        passBtn.Parent = frame
        passBtn.Size = UDim2.new(0,120,0,32)
        passBtn.Position = UDim2.new(0,150,0,90)
        passBtn.Text = "PASS: DIME"
        style(passBtn)

        -- THROW BUTTON
        local throwBtn = Instance.new("TextButton")
        throwBtn.Parent = gui
        throwBtn.Size = UDim2.new(0,150,0,65)
        throwBtn.Position = UDim2.new(0.78, 0, 0.78, 0)
        throwBtn.Text = "THROW"
        throwBtn.TextSize = 22
        throwBtn.ZIndex = 10
        style(throwBtn)
        Instance.new("UICorner", throwBtn).CornerRadius = UDim.new(0,18)

        -- TARGET FUNCTION
        local function getClosestTarget()
            local mousePos = UIS:GetMouseLocation()
            local myTeam = LocalPlayer.Replicated.TeamID.Value
            local best, dist = nil, math.huge

            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LocalPlayer and p.Character and p.Character:FindFirstChild("Head") then
                    local team = p.Replicated.TeamID.Value
                    if team == "" or team == myTeam then
                        local screenPos, onScreen =
                            Camera:WorldToViewportPoint(p.Character.Head.Position)

                        if onScreen then
                            local d = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                            if d < dist then
                                dist = d
                                best = p
                            end
                        end
                    end
                end
            end

            return best
        end

        -- THROW LOGIC
        local function throwBall()
            if not ThrowRemote then return end
            local char = LocalPlayer.Character
            if not char then return end

            local head = char:FindFirstChild("Head")
            if not head then return end

            local targetPlayer = locked and lockedTarget or getClosestTarget()
            if not targetPlayer or not targetPlayer.Character then return end

            local targetHead = targetPlayer.Character:FindFirstChild("Head")
            local hrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not targetHead or not hrp then return end

            local startPos = head.Position
            local vel = hrp.Velocity
            local flatVel = Vector3.new(vel.X, 0, vel.Z)
            local speed = flatVel.Magnitude
            local moveDir = speed > 1 and flatVel.Unit or (targetHead.Position - startPos).Unit

            local leaddist =
                pizztype == "Dime" and DimeLead
                or pizztype == "Mag" and MagLead
                or BulletLead

            local dist = (startPos - targetHead.Position).Magnitude

            local baseHeight =
                pizztype == "Dime" and DimeHeight
                or pizztype == "Mag" and MagHeight
                or BulletHeight

            local height = (dist / (ThrowAngle / 5)) + baseHeight
            local time = math.max(0.1, height * 0.11)

            local finalPos =
                targetHead.Position
                + flatVel * time
                + moveDir * leaddist
                + Vector3.new(0, 5, 0)

            local v0 = (finalPos - startPos - 0.5 * GRAVITY * time * time) / time
            local dir = v0.Unit
            local farTarget = startPos + dir * 10000

            ThrowRemote:FireServer("Mechanics", "ThrowBall", {
                Target = farTarget,
                AutoThrow = false,
                Power = math.clamp(math.round(v0.Magnitude), 0, 100)
            })
        end

        -- BUTTON CONNECTIONS
        throwBtn.MouseButton1Click:Connect(throwBall)

        UIS.InputBegan:Connect(function(input, gpe)
            if gpe then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                throwBall()
            end
        end)

        lockBtn.MouseButton1Click:Connect(function()
            locked = not locked
            lockedTarget = locked and getClosestTarget() or nil
        end)

        passBtn.MouseButton1Click:Connect(function()
            pizztype =
                pizztype == "Dime" and "Mag"
                or pizztype == "Mag" and "Bullet"
                or "Dime"

            passBtn.Text = "PASS: " .. pizztype
        end)

        RunService.RenderStepped:Connect(function()
            passLabel.Text = "Pass: " .. pizztype
            targetLabel.Text =
                locked and lockedTarget
                and ("Target: " .. lockedTarget.Name)
                or "Target: None"
        end)
    end
})

-- =========================
-- QB SETTINGS SLIDERS
-- =========================
ThrowingTab:CreateSection("QB Settings")

local function slider(name, min, max, current, callback)
    ThrowingTab:CreateSlider({
        Name = name,
        Range = {min, max},
        Increment = 1,
        CurrentValue = current,
        Callback = callback
    })
end

slider("Dime Lead",1,20,DimeLead,function(v) DimeLead=v end)
slider("Mag Lead",1,20,MagLead,function(v) MagLead=v end)
slider("Bullet Lead",1,20,BulletLead,function(v) BulletLead=v end)

slider("Dime Height",1,20,DimeHeight,function(v) DimeHeight=v end)
slider("Mag Height",1,20,MagHeight,function(v) MagHeight=v end)
slider("Bullet Height",1,20,BulletHeight,function(v) BulletHeight=v end)

slider("Angle",1,100,ThrowAngle,function(v) ThrowAngle=v end)

local CatchingTab = Window:CreateTab("Catching", nil)
CatchingTab:CreateSection("Catching")

--// UI

local ms67 = false
local dist = 120

local magnetToggle = CatchingTab:CreateToggle({
    Name = "Desync Magnet",
    CurrentValue = false,
    Flag = "Magnet_Toggle",
    Callback = function(v)
        ms67 = v
    end,
})

local magnetDistanceSlider = CatchingTab:CreateSlider({
    Name = "Mag Distance",
    Range = {1, 120},
    Increment = 1,
    CurrentValue = 50,
    Flag = "Mag_Distance",
    Callback = function(v)
        dist = v
    end,
})

--// Script

local plr = game.Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local og1 = CFrame.new()
local prvnt = false
local theonern = nil
local ifsm1gotfb = false

local function fbpos(fbtingy)
    local b4now = fbtingy:GetAttribute("oldp")
    local rn = fbtingy.Position
    fbtingy:SetAttribute("oldp", rn)
    return rn, b4now or rn
end

local function ifsm1gotit()
    if theonern and theonern.Parent then
        local parent = theonern.Parent
        if parent:IsA("Model") and game.Players:GetPlayerFromCharacter(parent) then
            return true
        end
        for _, player in next, game.Players:GetPlayers() do
            if player.Character and theonern:IsDescendantOf(player.Character) then
                return true
            end
        end
    end
    return false
end

local function udfr(fbtingy)
    theonern = fbtingy
    fbtingy:SetAttribute("oldp", fbtingy.Position)
end

workspace.DescendantAdded:Connect(function(d)
    if d.Name == "Football" and d:IsA("MeshPart") then
        udfr(d)
        ifsm1gotfb = false

        d.AncestryChanged:Connect(function()
            if d.Parent and d.Parent:IsA("Model") and game.Players:GetPlayerFromCharacter(d.Parent) then
                ifsm1gotfb = true
            elseif d.Parent == workspace or d.Parent == nil then
                ifsm1gotfb = false
            end
        end)
    end
end)

workspace.DescendantRemoving:Connect(function(d)
    if d == theonern then
        theonern = nil
        ifsm1gotfb = false
    end
end)

for _, d in next, workspace:GetDescendants() do
    if d.Name == "Football" and d:IsA("MeshPart") then
        udfr(d)
        if d.Parent and d.Parent:IsA("Model") and game.Players:GetPlayerFromCharacter(d.Parent) then
            ifsm1gotfb = true
        end
    end
end

local oind
oind = hookmetamethod(game, "__index", function(self, key)
    if ms67 and not checkcaller() and key == "CFrame" and self == hrp and prvnt then
        return og1
    end
    return oind(self, key)
end)

game:GetService("RunService").Heartbeat:Connect(function()
    if not ms67 or not theonern or not theonern.Parent then
        ifsm1gotfb = false
        return
    end

    ifsm1gotfb = ifsm1gotit()
    if ifsm1gotfb then
        prvnt = false
        return
    end

    local pos, old = fbpos(theonern)
    local d0 = (hrp.Position - pos).Magnitude
    if d0 > dist then return end

    local vel = pos - old
    local int1

    if vel.Magnitude > 0.1 then
        local predicted = pos + vel
        int1 = predicted + (vel.Unit * 10)
    else
        int1 = pos + Vector3.new(10, 0, 10)
    end

    int1 = Vector3.new(int1.X, math.max(int1.Y, pos.Y), int1.Z)

    og1 = hrp.CFrame
    prvnt = true
    hrp.CFrame = CFrame.new(int1)
    game:GetService("RunService").RenderStepped:Wait()
    hrp.CFrame = og1
    prvnt = false
end)

plr.CharacterAdded:Connect(function(c2)
    char = c2
    hrp = c2:WaitForChild("HumanoidRootPart")
    prvnt = false
end)

--// UI TOGGLE

local pullEnabled = false

local pullToggle = CatchingTab:CreateToggle({
    Name = "Pull Vector (Teleport)",
    CurrentValue = false,
    Flag = "Pull_Vector_Toggle",
    Callback = function(v)
        pullEnabled = v
    end,
})

--// PULL VECTOR (TELEPORT MODE)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer

-- SETTINGS
local PULL_DISTANCE = 20
local SNAP_OFFSET = Vector3.new(0, 2, 0)

local function getClosestFootball()
    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local hrp = char.HumanoidRootPart
    local closest, dist = nil, math.huge

    for _, obj in pairs(Workspace:GetChildren()) do
        if obj:IsA("BasePart")
            and obj.Name:lower():find("football")
            and not obj.Anchored then

            local d = (hrp.Position - obj.Position).Magnitude
            if d < dist and d <= PULL_DISTANCE then
                closest = obj
                dist = d
            end
        end
    end

    return closest
end

RunService.Heartbeat:Connect(function()
    if not pullEnabled then return end

    local char = player.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end

    local ball = getClosestFootball()
    if not ball then return end

    local hrp = char.HumanoidRootPart

    -- TELEPORT BALL TO PLAYER
    ball.CFrame = hrp.CFrame + SNAP_OFFSET
end)

--// UI TOGGLE

local highlightEnabled = false
local highlighted = {}

local highlightToggle = CatchingTab:CreateToggle({
    Name = "Highlight Football",
    CurrentValue = false,
    Flag = "Football_Highlight_Toggle",
    Callback = function(v)
        highlightEnabled = v

        if not v then
            -- Remove all highlights when disabled
            for ball, _ in pairs(highlighted) do
                if ball and ball:FindFirstChildOfClass("Highlight") then
                    ball:FindFirstChildOfClass("Highlight"):Destroy()
                end
            end
            table.clear(highlighted)
        else
            scanForFootballs()
        end
    end,
})

--// SCRIPT

repeat task.wait() until game:IsLoaded()

local Workspace = game:GetService("Workspace")

-- Color + transparency settings
local highlightColor = Color3.fromRGB(255, 255, 0)
local fillTransparency = 0.5
local outlineTransparency = 0

local function highlightFootball(ball)
    if not highlightEnabled then return end
    if highlighted[ball] then return end

    local h = Instance.new("Highlight")
    h.FillColor = highlightColor
    h.FillTransparency = fillTransparency
    h.OutlineTransparency = outlineTransparency
    h.Adornee = ball
    h.Parent = ball

    highlighted[ball] = h
end

function scanForFootballs()
    if not highlightEnabled then return end

    for _, obj in ipairs(Workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj.Name == "Football" then
            highlightFootball(obj)
        end
    end
end

-- Detect new footballs instantly
Workspace.DescendantAdded:Connect(function(obj)
    if highlightEnabled and obj:IsA("BasePart") and obj.Name == "Football" then
        highlightFootball(obj)
    end
end)

local DefenseTab = Window:CreateTab("Defense", nil)
DefenseTab:CreateSection("Defense")

--// UI TOGGLE

local autoRushEnabled = false

local autoRushToggle = DefenseTab:CreateToggle({
    Name = "Auto QB Rush",
    CurrentValue = false,
    Flag = "Auto_Rush_Toggle",
    Callback = function(v)
        autoRushEnabled = v
        
        -- Stop movement instantly when turned off
        if not v and humanoid then
            humanoid:Move(Vector3.zero, false)
        end
    end,
})

--// SCRIPT

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

local minPredict = 0.15
local maxPredict = 0.65
local maxDistance = 50

-- Only check real input-based movement
local function isPlayerMoving()
    return humanoid.MoveDirection.Magnitude > 0.05
end

local function findBallHolder()
    local football = workspace:FindFirstChild("Football", true)
    if not football then return nil end

    local parent = football.Parent
    if parent then
        if parent:FindFirstChild("Humanoid") then
            return Players:GetPlayerFromCharacter(parent)
        end
        if parent:IsA("Tool") and parent.Parent and parent.Parent:FindFirstChild("Humanoid") then
            return Players:GetPlayerFromCharacter(parent.Parent)
        end
    end

    return nil
end

RunService.RenderStepped:Connect(function()
    if not autoRushEnabled then return end

    -- If user is moving manually, don't auto rush
    if isPlayerMoving() then
        return
    end

    local targetPlayer = findBallHolder()
    if not targetPlayer or targetPlayer == player then
        humanoid:Move(Vector3.zero, false)
        return
    end

    local targetChar = targetPlayer.Character
    local targetHRP = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return end

    local distance = (targetHRP.Position - hrp.Position).Magnitude
    local t = math.clamp(distance / maxDistance, 0, 1)
    local dynamicPredict = minPredict + (maxPredict - minPredict) * t

    local predictedPos = targetHRP.Position + (targetHRP.Velocity * dynamicPredict)
    local direction = (predictedPos - hrp.Position)

    if direction.Magnitude < 1 then
        direction = (targetHRP.Position - hrp.Position)
    end

    humanoid:Move(direction.Unit, false)
end)

-- Handle respawn
player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
    hrp = char:WaitForChild("HumanoidRootPart")
end)

--// UI TOGGLE

local forceTouchEnabled = false

local forceTouchToggle = DefenseTab:CreateToggle({
    Name = "Auto Tackle",
    CurrentValue = false,
    Flag = "Force_Touch_Toggle",
    Callback = function(v)
        forceTouchEnabled = v
    end,
})

--// SCRIPT

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function getBall()
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj.Name == "Football" and obj:IsA("BasePart") then
            return obj
        end
    end
end

local function getBallHolder(ball)
    local parent = ball.Parent
    if parent and parent:FindFirstChild("Humanoid") then
        return parent
    end
end

local function isMoving(character)
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    return hrp.Velocity.Magnitude > 2
end

local function forceTouch(char1, char2)
    local hrp1 = char1:FindFirstChild("HumanoidRootPart")
    local hrp2 = char2:FindFirstChild("HumanoidRootPart")
    if not hrp1 or not hrp2 then return end

    -- Teleport slightly inside them to guarantee touch
    hrp1.CFrame = hrp2.CFrame * CFrame.new(0, 0, 1)
end

RunService.Heartbeat:Connect(function()
    if not forceTouchEnabled then return end

    local char = player.Character
    if not char then return end

    local ball = getBall()
    if not ball then return end

    local holder = getBallHolder(ball)
    if not holder then return end
    if holder == char then return end -- don't tackle yourself

    -- If holder is moving, wait 2 seconds before tackling
    if isMoving(holder) then
        task.wait(2)
    end

    -- Teleport and force touch
    forceTouch(char, holder)
end)

--// UI TOGGLE

local giantHeadEnabled = false

local giantHeadToggle = DefenseTab:CreateToggle({
    Name = "Tackle Reach",
    CurrentValue = false,
    Flag = "Giant_Heads_Toggle",
    Callback = function(v)
        giantHeadEnabled = v
    end,
})

--// SCRIPT

local Players = game:GetService("Players")

local function applyHeadSettings(char)
    if not giantHeadEnabled then return end

    local head = char:FindFirstChild("Head")
    if not head then return end

    head.Size = Vector3.new(10, 10, 10)
    head.Transparency = 1
    head.Massless = true

    local mesh = head:FindFirstChildOfClass("SpecialMesh")
    if mesh then
        mesh:Destroy()
    end
end

local function onCharacterAdded(character)
    task.wait(0.1)
    applyHeadSettings(character)
end

local function onPlayerAdded(player)
    player.CharacterAdded:Connect(onCharacterAdded)

    if player.Character then
        onCharacterAdded(player.Character)
    end
end

-- Apply to everyone in server
for _, player in pairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end

Players.PlayerAdded:Connect(onPlayerAdded)

--// UI TOGGLE

local magnetEnabled = false

local magnetToggle = CatchingTab:CreateToggle({
    Name = "Auto Interception",
    CurrentValue = false,
    Flag = "Desync_Magnet_Toggle",
    Callback = function(v)
        magnetEnabled = v
    end,
})

--// SCRIPT

local dist = 120

local plr = game.Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

local theonern = nil
local ifsm1gotfb = false

local function fbpos(fbtingy)
    local old = fbtingy:GetAttribute("oldp")
    local now = fbtingy.Position
    fbtingy:SetAttribute("oldp", now)
    return now, old or now
end

local function ifsm1gotit()
    if theonern and theonern.Parent then
        local parent = theonern.Parent
        if parent:IsA("Model") and game.Players:GetPlayerFromCharacter(parent) then
            return true
        end
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Character and theonern:IsDescendantOf(player.Character) then
                return true
            end
        end
    end
    return false
end

local function udfr(fbtingy)
    theonern = fbtingy
    fbtingy:SetAttribute("oldp", fbtingy.Position)
end

workspace.DescendantAdded:Connect(function(d)
    if d.Name == "Football" and d:IsA("MeshPart") then
        udfr(d)
        ifsm1gotfb = false

        d.AncestryChanged:Connect(function()
            if d.Parent and d.Parent:IsA("Model") and game.Players:GetPlayerFromCharacter(d.Parent) then
                ifsm1gotfb = true
            elseif d.Parent == workspace or d.Parent == nil then
                ifsm1gotfb = false
            end
        end)
    end
end)

workspace.DescendantRemoving:Connect(function(d)
    if d == theonern then
        theonern = nil
        ifsm1gotfb = false
    end
end)

for _, d in ipairs(workspace:GetDescendants()) do
    if d.Name == "Football" and d:IsA("MeshPart") then
        udfr(d)
        if d.Parent and d.Parent:IsA("Model") and game.Players:GetPlayerFromCharacter(d.Parent) then
            ifsm1gotfb = true
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(function()
    if not magnetEnabled or not theonern or not theonern.Parent then
        ifsm1gotfb = false
        return
    end

    ifsm1gotfb = ifsm1gotit()
    if ifsm1gotfb then return end

    local pos, old = fbpos(theonern)
    local d0 = (hrp.Position - pos).Magnitude
    if d0 > dist then return end

    -- BALL VELOCITY
    local vel = pos - old
    local target

    if vel.Magnitude > 0.05 then
        -- TRUE PREDICTION:
        local predicted = pos + vel
        target = predicted + vel.Unit * 10
    else
        target = pos
    end

    -- Keep Y safe
    local safeY = math.max(target.Y, hrp.Position.Y)

    -- FINAL TELEPORT
    hrp.CFrame = CFrame.new(target.X, safeY, target.Z)
end)

plr.CharacterAdded:Connect(function(c2)
    char = c2
    hrp = c2:WaitForChild("HumanoidRootPart")
end)

local PhysicsTab = Window:CreateTab("Physics", nil)
PhysicsTab:CreateSection("Physics")

--// UI

local cframeSpeedEnabled = false
local SPEED = 2.2

local speedToggle = PhysicsTab:CreateToggle({
    Name = "CFrame WalkSpeed",
    CurrentValue = false,
    Flag = "CFrame_Speed_Toggle",
    Callback = function(v)
        cframeSpeedEnabled = v
    end,
})

local speedSlider = PhysicsTab:CreateSlider({
    Name = "CFrame Speed",
    Range = {1, 5},
    Increment = 0.1,
    CurrentValue = 2.2,
    Flag = "CFrame_Speed_Value",
    Callback = function(v)
        SPEED = v
    end,
})

--// SCRIPT

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

RunService.RenderStepped:Connect(function()
    if not cframeSpeedEnabled then return end

    local char = player.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end

    local moveDir = hum.MoveDirection
    if moveDir.Magnitude > 0 then
        hrp.CFrame = hrp.CFrame + (moveDir * SPEED)
    end
end)

--// UI TOGGLE (Put in Defense or Physics tab)

local armHitboxEnabled = false

local armHitboxToggle = PhysicsTab:CreateToggle({
    Name = "Tall Arm Hitbox",
    CurrentValue = false,
    Flag = "Tall_Arm_Hitbox_Toggle",
    Callback = function(v)
        armHitboxEnabled = v

        local player = game.Players.LocalPlayer
        local character = player.Character
        if not character then return end

        local leftArm = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftHand")
        local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightHand")

        if v then
            -- ENABLE HITBOX
            if leftArm then
                leftArm.Size = Vector3.new(5, 50, 5)
                leftArm.Transparency = 1
                leftArm.Material = Enum.Material.Neon
                leftArm.CanCollide = false
            end

            if rightArm then
                rightArm.Size = Vector3.new(5, 50, 5)
                rightArm.Transparency = 1
                rightArm.Material = Enum.Material.Neon
                rightArm.CanCollide = false
            end
        else
            -- RESTORE NORMAL ARMS
            if leftArm then
                leftArm.Size = Vector3.new(1, 2, 1)
                leftArm.Transparency = 0
                leftArm.Material = Enum.Material.Plastic
            end

            if rightArm then
                rightArm.Size = Vector3.new(1, 2, 1)
                rightArm.Transparency = 0
                rightArm.Material = Enum.Material.Plastic
            end
        end
    end,
})

--// UI TOGGLE (Put in PhysicsTab)

local burstBoostEnabled = false

local burstBoostToggle = PhysicsTab:CreateToggle({
    Name = "Auto Speed Boost",
    CurrentValue = false,
    Flag = "Burst_Boost_Toggle",
    Callback = function(v)
        burstBoostEnabled = v
    end,
})

--// SCRIPT

repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

player.CharacterAdded:Connect(function(char)
    character = char
    humanoid = char:WaitForChild("Humanoid")
    hrp = char:WaitForChild("HumanoidRootPart")
end)

-- SETTINGS
local boostStrength = 0.5
local boostDuration = 0.15
local boostCooldown = 2

local boosting = false
local lastBoost = 0

RunService.Heartbeat:Connect(function()
    if not burstBoostEnabled then return end
    if not humanoid or not hrp then return end

    local moveDir = humanoid.MoveDirection
    if moveDir.Magnitude == 0 then return end

    if tick() - lastBoost >= boostCooldown and not boosting then
        boosting = true
        lastBoost = tick()

        task.spawn(function()
            local startTime = tick()
            while tick() - startTime < boostDuration and burstBoostEnabled do
                hrp.CFrame = hrp.CFrame + (moveDir * boostStrength)
                RunService.Heartbeat:Wait()
            end
            boosting = false
        end)
    end
end)

--// UI (Physics Tab)

local angleEnhancerEnabled = false
local boostedJumpPower = 65

local angleToggle = PhysicsTab:CreateToggle({
    Name = "Angle Enhancer",
    CurrentValue = false,
    Flag = "Angle_Enhancer_Toggle",
    Callback = function(v)
        angleEnhancerEnabled = v
    end,
})

local jumpSlider = PhysicsTab:CreateSlider({
    Name = "Boosted Jump Power",
    Range = {50, 120},
    Increment = 1,
    CurrentValue = 65,
    Flag = "Angle_Enhancer_Power",
    Callback = function(v)
        boostedJumpPower = v
    end,
})

--// SCRIPT

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")

    humanoid.StateChanged:Connect(function(_, newState)
        if newState == Enum.HumanoidStateType.Jumping and angleEnhancerEnabled then
            task.wait(0.05)

            hrp.AssemblyLinearVelocity = Vector3.new(
                hrp.AssemblyLinearVelocity.X,
                boostedJumpPower,
                hrp.AssemblyLinearVelocity.Z
            )
        end
    end)
end

-- INIT
if player.Character then
    setupCharacter(player.Character)
end

player.CharacterAdded:Connect(setupCharacter)
